!
!Copyright 2015 University of Chicago
!
!Licensed under the Apache License, Version 2.0 (the "License");
!you may not use this file except in compliance with the License.
!You may obtain a copy of the License at
!
!    http://www.apache.org/licenses/LICENSE-2.0
!
!Unless required by applicable law or agreed to in writing, software
!distributed under the License is distributed on an "AS IS" BASIS,
!WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
!See the License for the specific language governing permissions and
!limitations under the License.

!This program takes maps (such as those generated by CGMGC) and applies them to
!trajectories.  The maps are converted if possible to apply to the trajectory:
!e.g., parameterize on a monomer, and this can easily apply it to a polymer. The
!trajectories must be given as psf/dcd, and the map is given as a file of
!integers divided by newlines. The row number determines the atom under
!consideration, and the given integer specifies the CG site it maps to. E.g.
!1
!1
!2
!maps 1->1, 2->1, 3->2, in the form (atom id)->(CG site id).
!Note that this requires sometimes a simple text reformatting from native CGMGC
!output.

!Multiple trajectories can be given, in which case they are superimposed in the
!final trajectory.

!contains objects/routines used for parameterization.
module obj_design

        use env_kindtypes, only: si,dp

        implicit none

        !general buffer for reading in strings. There isn't a perfectly safe buffer for most systems.
        !Alloctable strings don't work for reading.
        integer, parameter :: string_length = 4096
        
        !holds options to control runtime, usually parameterized via command
        !line.
        type                             :: design

                logical                                  :: write_charges = .false., write_masses = .false.
                !whether to put atom labels in the masses file.
                logical                                  :: label_masses_flag = .false.
                !these are arrays of strings.
                character(len=string_length),allocatable :: psf_files(:), dcd_files(:), mapping_files(:)
                character(len=:),            allocatable :: charges_file,masses_file
                character(len=:),            allocatable :: accum_type, mapped_traj_file, map_op
                logical                                  :: calc_rog = .false., remove_zero_charge = .false.

                integer                                  :: num_trajs = 0

                contains
                        procedure :: get_options => extract_command_line

        end type design

        contains
                !populates options based on given command line values.
                subroutine extract_command_line(self)

                        use obj_commandline,    only: get_option_value_string,&
                                                      sget_option_value_static_string_array

                        implicit none

                        class (design), intent(inout)   :: self

                        character(:),allocatable        :: arg
                        integer (si)                    :: arg_index

                         arg_index = 1
                         do
                         if (arg_index > command_argument_count()) exit
                         arg = get_option_value_string(arg_index,increment_index=.true.)
                         select case (arg)
                         case ('--psf-files')
                                 call sget_option_value_static_string_array(&
                                                        self%psf_files,arg_index,increment_index=.true.)
                         case ('--dcd-files')
                                 call sget_option_value_static_string_array(&
                                                        self%dcd_files,arg_index,increment_index=.true.)
                         case ('--map-files')
                                 call sget_option_value_static_string_array(&
                                                        self%mapping_files,arg_index,increment_index=.true.)
                         case ('--charges-file')
                                 self%write_charges = .true.
                                 self%charges_file = get_option_value_string(arg_index,increment_index=.true.)
                         case ('--masses-file')
                                 self%write_masses = .true.
                                 self%masses_file = get_option_value_string(arg_index,increment_index=.true.)
                         case ('--label-atoms-masses-file')
                                 self%label_masses_flag = .true.
                         case ('-x')
                                 self%map_op   = get_option_value_string(arg_index,increment_index=.true.)
                         case ('--accum-type')
                                 self%accum_type = get_option_value_string(arg_index,increment_index=.true.)
                         case ('-o')
                                 self%mapped_traj_file = get_option_value_string(arg_index,increment_index=.true.)
                         case ('--rog')
                                 self%calc_rog = .true.
                         case ('--remove-zero-charge-cg-sites')
                                 self%remove_zero_charge = .true.
                         case default
                                 print '(a,a,/)', 'ERROR: Unrecognized command-line option: ', arg
                                 stop
                         end select
                         enddo

                         !Check to see if we have a valid set of options.
                         if (.not. (      allocated(self%dcd_files) &
                                    .and. allocated(self%psf_files) &
                                    .and. allocated(self%mapping_files))) then
                                 print*, "Insufficient commandline specification. Command line options needed:"
                                 print*, "--psf-files [input psf files, space delimited]"
                                 print*, "--dcd-files [input dcd files, space delimited]"
                                 print*, "--map-files [input map files, space delimited, 1 site per newline]"
                                 print*, "Additional command line options:"
                                 print*, "--charges-file [output file to put mapped charges]"
                                 print*, "--masses-file  [output file to put mapped masses]"
                                 print*, "--label-atoms-masses-file"
                                 print*, "-x [mapping operation, currently only 'stack']"
                                 print*, "--accum-type [function to use for map operation: 'cop', 'com', 'coc']"
                                 print*, "-o output xyz trajectory name"
                                 print*, "--rog to calculate radius of gyration information."
                                 print*, "--remove-zero-charge-cg-sites to remove CG sites in the representation &
                                         &which have a sum of zero charge. This is equivalent to modifying the input map. &
                                         &Useful mainly in conjunction with a charge split map."
                                 print*, "Options default to 'stack', 'cop', 'mapped_traj.xyz', no rog, no remove by &
                                         &charge critera."
                                 stop
                         endif

                         !set default options

                         if (.not. allocated(self%map_op)) then
                                 self%map_op = 'stack'
                         endif

                         if (.not. allocated(self%accum_type)) then
                                 self%accum_type = 'cop'
                         endif

                         if (.not. allocated(self%mapped_traj_file)) then
                                 self%mapped_traj_file = 'mapped_traj.xyz'
                         endif

                         if (size(self%psf_files) /= size(self%dcd_files) .or. &
                             size(self%psf_files) /= size(self%mapping_files)) then
                                 print*, "ERROR: Varying numbers of mappings and trajectories given."
                                 print*, "ERROR: Stopping."
                                 stop
                         else
                                 self%num_trajs = size(self%psf_files)
                         endif
                endsubroutine extract_command_line

endmodule obj_design

program map_munge

        use env_kindtypes,              only: si, dp
        use obj_stopwatch,              only: stopwatch
        use obj_trajectory,             only: traj, labeledTraj
        use obj_design,                 only: design
        use core_filter,                only: canonicizeMapping, mapStack
        use IO_csv,                     only: write_csv

        implicit none

        integer (si),allocatable :: master_map(:), filter_indices(:)
        integer (si)             :: iter, file_id
        logical,allocatable      :: charge_mask(:)
        type(design)             :: options
        type(labeledTraj),allocatable :: trajs(:)
        type(labeledTraj)        :: full_traj, mtrj
        type(stopwatch)          :: timer

        !bookkeeping.
        call timer%start()

        !get options from command line.
        call options%get_options()

        !allocate our list of trajectories we will work with.
        !We'll read each individual traj and then combine them.
        allocate(trajs(options%num_trajs))

        !populate trajectories
        do iter=1,options%num_trajs
                trajs(iter) = labeledTraj( options%psf_files(iter), &
                                           options%dcd_files(iter))
        enddo

        !Create the total trajectory, superimposing the trajectories given.
        full_traj = labeledTraj(trajs)

        !Create map for the entire trajectory:
        ! 1. We need to expand the read map to fit the trajectory, e.g. 
        !    repeat a monomer map for a polymer.
        ! 2. We then need to combine the maps for each part into a single big map.
        map_create: block
                integer (si), allocatable :: local_map(:)

                !We act on the first trajectory, and then loop through the rest if needed
                !(the actions for the first are slightly different)

                !read first map
                local_map  = read_map(options%mapping_files(1))
                !expand map to fit molecule, assign to total map.
                master_map = conv_map(local_map,trajs(1),options%map_op)

                do iter=2,size(trajs)
                        local_map = read_map(options%mapping_files(iter))
                        local_map = conv_map(local_map,trajs(iter),options%map_op)
                        !combine map with exists maps.
                        master_map = mapStack(master_map,local_map)
                enddo
        endblock map_create

        !Map the combined trajectory.
        mtrj = map_traj(full_traj,master_map,options%accum_type)

        !If requested, filter our results: remove 0 charge sites. This is done by creating
        !a filter of which atoms indices to keep; this is used in _reporting_ results.
        !If we were to filter the trajectory immediately, calculating the ROG
        !takes more work. Still, this is nonideal.

        charge_filter: block
                use core_stat, only: seq, which
                real (dp),parameter     :: charge_tol = 10.0_dp**(-13)

                if (options%remove_zero_charge) then
                        charge_mask = (abs(mtrj%atomCharges) > charge_tol)
                        filter_indices = which(charge_mask)
                else
                        allocate(charge_mask(mtrj%nAtoms),source=.true.)
                        filter_indices = seq(1,mtrj%nAtoms)
                endif
        endblock charge_filter

        !If requested, write charge file.
        if (options%write_charges) then
                open(newunit = file_id, file = options%charges_file)
                do iter=1,size(filter_indices)
                        write(file_id,*) mtrj%atomCharges(filter_indices(iter))
                enddo
                close(file_id)
        endif

        !If requested, write mass file.
        if (options%write_masses) then
                open(newunit = file_id, file = options%masses_file)
                if (options%label_masses_flag .and. allocated(mtrj%site_labels)) then
                        do iter=1,size(filter_indices)
                                write(file_id,*) mtrj%site_labels(filter_indices(iter)), &
                                                 mtrj%site_mass(filter_indices(iter))
                        enddo
                else 
                        do iter=1,size(filter_indices)
                                write(file_id,*) mtrj%site_mass(filter_indices(iter))
                        enddo
                endif
                close(file_id)
        endif

        !If requested, calculate and write radius of gyration for each bead.
        rog: block
                type    (traj)           :: rog_trj
                real    (dp),allocatable :: avg_rog(:,:)
                if (options%calc_rog) then

                        rog_trj = full_traj%genROGtraj(master_map)

                        avg_rog = rog_trj%genAvgStruct()
                        call write_csv("avg_rog.csv",avg_rog(filter_indices,1))

                        call rog_trj%strip(charge_mask)

                        call rog_trj%writeCSVfile("rog_traj.csv")
                endif
        endblock rog

        !Finally, we strip the trajectory using our used filter and write the results.
        call mtrj%strip(charge_mask)
        call mtrj%writeXYZfile(options%mapped_traj_file)

        !report time used.
        call timer%finish()
        call timer%report(prefix=' INFO: ')

        contains

                !takes a map (array) and modified it to be applicable to a trajectory.
                !the map is modified first accordint to @op.
                !
                !map is assumed canonical (assignements from 1 to n, no skipping).
                function conv_map(input_map,trajectory,op) result(output_map)

                        use obj_trajectory,     only: labeledTraj
                        use env_kindtypes,      only: si

                        implicit none

                        integer (si),       intent(in   )   :: input_map(:)
                        type (labeledTraj), intent(in   )   :: trajectory
                        character(*),       intent(in   )   :: op

                        integer (si),   allocatable         :: output_map(:)
                        integer (si)                        :: iter1, iter2, num_atoms
                        integer (si)                        :: num_orig_sites, write_index

                        if (size(input_map) == trajectory%nAtoms) then
                                print*, 'INFO: (map conv) Map is fully determined-- only a simply convert/copy performed.'
                                output_map = input_map
                                return
                        endif

                        num_atoms = trajectory%nAtoms

                        num_orig_sites = maxval(input_map)

                        write_index = 0

                        select case (op)
                        case ('stack')
                                allocate(output_map(num_atoms))
                                if (mod(num_atoms,size(input_map)) == 0) then
                                        print*, 'INFO: (map conv) Map looks like it can be tesslated; stacking maps.'
                                        do iter1=0,(num_atoms/size(input_map)- 1)
                                        do iter2=1,size(input_map)
                                                write_index = write_index + 1
                                                output_map(write_index) = input_map(iter2) + num_orig_sites*iter1
                                        enddo
                                        enddo
                                else
                                        print*, "ERROR: (map conv) Bad stack directions. Stopping."
                                        print*, "ERROR: (map conv) Check the number of atoms in the map and mapee."
                                        print*, "ERROR: (map conv) Size of given map:", size(input_map)
                                        print*, "ERROR: (map conv) Size of given trajectory:", num_atoms
                                        stop
                                endif
                        case default 
                                print*, 'ERROR: (map conv) Unrecognized map option: ', op
                                stop
                        end select
                endfunction conv_map

                function read_map(filename,canonicize) result(output_map)

                        use env_kindtypes,      only: si

                        implicit none

                        character(*),intent(in   )      :: filename
                        logical,optional                :: canonicize

                        integer (si),allocatable        :: output_map(:)

                        integer (si)    :: fp,val,stat,map_size,iter
                        logical         :: canonicize_

                        if (present(canonicize)) then
                                canonicize_ = canonicize
                        else
                                canonicize_ = .false.
                        endif

                        open(newunit=fp,file=filename)

                        map_size = 0
                        do while (.true.)
                                read (unit=fp,fmt=*,iostat=stat)  val
                                if (stat /= 0) then
                                        exit
                                endif
                                map_size = map_size + 1
                        enddo

                        rewind(fp)

                        allocate(output_map(map_size))

                        read(unit=fp,fmt=*) (output_map(iter),iter=1,map_size)

                        close(fp)

                endfunction read_map

                function map_traj(src_trj,map,map_op) result(mtrj)

                        use env_kindtypes,      only: si
                        use obj_trajectory,     only: traj, labeledTraj

                        implicit none

                        character(*),            intent(in   )  :: map_op
                        integer (si),            intent(in   )  :: map(:)
                        type (labeledTraj),      intent(in   )  :: src_trj

                        type (labeledTraj)                      :: mtrj

                        !map trajectory
                        select case (map_op)
                        case ("cop")
                                mtrj = src_trj%lmapTrajectory(map = map)
                        case ("com")
                                mtrj = src_trj%lmapTrajectory(map = map,&
                                             position_weights = src_trj%site_mass)
                        case ("coc")
                                mtrj = src_trj%lmapTrajectory(map = map,&
                                             position_weights = src_trj%atomCharges)
                        endselect

                endfunction map_traj

                !this function removes certain entire sites from a map.
                ! @removal_ids specifies the _labels_ (not positions in map) of the 
                !   map ids to remove.
                ! if @canonicize == .true., then canonicize the returned map.
                pure function trim_map(map,removal_ids,canonicize)

                        use env_kindtypes,      only: si
                        use core_filter,        only: canonicizeMapping

                        implicit none

                        integer (si),            intent(in   )  :: map(:)
                        integer (si),            intent(in   )  :: removal_ids(:)
                        logical,     optional,   intent(in   )  :: canonicize

                        integer (si), allocatable :: trim_map(:)

                        logical         :: canonicize_

                        logical,allocatable :: to_keep_mask(:), curr_mask(:)
                        integer             :: iter, write_mark

                        if (present(canonicize)) then
                                canonicize_ = canonicize
                        else
                                canonicize_ = .false.
                        endif

                        !check corner conditions
                        if (size(removal_ids) == 0) then
                                trim_map = map
                                if (canonicize_) then
                                        call canonicizeMapping(trim_map)
                                        return
                                endif
                        endif

                        allocate(to_keep_mask(size(map)))
                        to_keep_mask = .true.

                        !generate mask for removal of entries.
                        do iter=1,size(removal_ids)
                                curr_mask = (map /= removal_ids(iter))
                                call elementwise_inplace_and(to_keep_mask,curr_mask)
                        enddo

                        allocate(trim_map(count_true(curr_mask)))

                        !next open location to write.
                        write_mark = 1

                        !cycle through, transfer value if needed.
                        do iter=1,size(map)
                                if (to_keep_mask(iter)) then
                                        trim_map(write_mark) = map(iter)
                                        write_mark = write_mark + 1
                                endif
                        enddo

                endfunction trim_map

                !performs inplace elementwise 'or' on inplace array. No checks on length consistency done.
                pure subroutine elementwise_inplace_and(inplace_array,compare_array)

                        use env_kindtypes,      only: si

                        logical,            intent(inout)  :: inplace_array(:)
                        logical,            intent(in   )  :: compare_array(:)

                        integer (si) :: iter

                        do iter=1,size(inplace_array)
                                inplace_array(iter) = compare_array(iter) .and. inplace_array(iter)
                        enddo

                endsubroutine  elementwise_inplace_and

                !count occurences of .true. in array.
                pure function count_true(array)

                        logical, intent(in) :: array(:)

                        integer (si) :: count_true

                        integer (si) :: iter

                        count_true = 0

                        do iter=1,size(array)
                                if (array(iter)) count_true = count_true + 1
                        enddo

                endfunction count_true

endprogram map_munge
